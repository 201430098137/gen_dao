package main

import (
	"bytes"
	"fmt"
	"github.com/pkg/errors"
	"go/format"
	"os"
	"strings"
	"text/template"
	"unicode"
)

func main() {
	//生成dao
	//a, err := gen(map[string]string{})
	//if err != nil {
	//	panic(err)
	//}
	//println(string(a))

	//生成orm
	gen2()
}

// tpl 生成代码需要用到模板
const tpl = `
// Code generated by github.com/mohuishou/gen-const-msg DO NOT EDIT

// {{.pkg}} const code comment msg
package {{.pkg}}

import (
	"code.speakin.mobi/fusion_cloud/meeting_system/orm"
	"errors"
	"github.com/jinzhu/gorm"
)

type _{{.tableName}}Dao struct {
	db *gorm.DB
}

func new{{.tableName}}Dao(db *gorm.DB) (*_{{.tableName}}Dao, error) {
	a := &orm.{{.tableName}}{}
	err := db.Set("gorm:table_options", "comment '权限表'").AutoMigrate(a).Error
	if err != nil {
		return nil, errors.New(err.Error())
	}

	return &_{{.tableName}}Dao{db.Model(a)}, nil
}

type {{.tableName}}QueryCondition struct {
	{{.tableName}}Ids []int64
}

func (authorityDao *_{{.tableName}}Dao) GetListByCond(cond {{.tableName}}QueryCondition) ([]*orm.{{.tableName}}, error) {
	query := authorityDao.db
	if len(cond.{{.tableName}}Ids) != 0 {
		query = query.Where("authorityId IN (?)", cond.{{.tableName}}Ids)
	}

	list := make([]*orm.{{.tableName}}, 0)
	err := query.Find(&list).Error
	if err != nil {
		return nil, err
	}
	return list, nil
}
`

// gen 生成代码
func gen(comments map[string]string) ([]byte, error) {
	var buf = bytes.NewBufferString("")

	data := map[string]interface{}{
		"pkg":       "mysql_dao",
		"tableName": "MeetingMemberRelate",
	}

	t, err := template.New("").Parse(tpl)
	if err != nil {
		return nil, errors.Wrap(err, "template init err")
	}

	err = t.Execute(buf, data)
	if err != nil {
		return nil, errors.Wrap(err, "template data err")
	}

	return format.Source(buf.Bytes())
}

func gen2() {

	str := "### 转写记录关联表 translation_record_relate\n字段名|类型|说明\n--|--|--\nid|int64|唯一标识\ntitle|string|主题名\nrelateType|string|关联类型:online线上 offline线下\nrelateId|int64|关联id\nstartTime|int64|开始时间\nabstract|text(500)|摘要\nbelongUserId|int64|所属用户id\ncreateTime|int64|创建时间\nupdateTime|int64|创建时间"

	strs := strings.Split(str, "\n")
	table := strs[0]
	table = strings.TrimPrefix(table, "###")
	table = strings.TrimSpace(table)
	tables := strings.Split(table, " ")
	//tableComment := tables[0]
	tableName := tables[1]

	f, err := os.Create(tableName + ".go")
	if err != nil {
		panic(err)
	}

	fmt.Fprintln(f, "package orm")
	fmt.Fprintln(f, "type "+strings.Title(tableName)+" struct {")
	for _, field := range strs[3:] {
		fields := strings.Split(field, "|")
		fieldName := fields[0]
		fieldType := fields[1]
		fieldComment := fields[2]

		defaultVal := "0"
		switch fieldName {
		case "string":
			defaultVal = "''"
		}

		fmt.Fprintln(f, strings.Title(fieldName)+" "+fieldType+" `gorm:\"column:"+fieldName+";NOT NULL;default"+
			":"+defaultVal+
			";comment"+
			":'"+fieldComment+"'\"`")
	}
	fmt.Fprintln(f, "}")

	fmt.Fprintf(f, "func ("+strings.Title(tableName)+") TableName() string {")
	fmt.Fprintln(f, "return \""+Camel2Case(tableName)+"\"")
	fmt.Fprintln(f, "}")

	//func (info *Member) String() string {
	//	return toString(info)
	//}
	fmt.Fprintf(f, "func (info *"+strings.Title(tableName)+") String() string {")
	fmt.Fprintln(f, "return toString(info)")
	fmt.Fprintln(f, "}")
}

func Camel2Case(name string) string {
	buffer := strings.Builder{}
	buffer.Grow(len(name) + 20)
	for i, r := range name {
		if unicode.IsUpper(r) {
			if i != 0 {
				buffer.WriteByte('_')
			}
			buffer.WriteRune(unicode.ToLower(r))
		} else {
			buffer.WriteRune(r)
		}
	}
	return buffer.String()
}
